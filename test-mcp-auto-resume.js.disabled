#!/usr/bin/env node

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function runTest() {
  console.log('üß™ Testing Auto-Resume with MCP Tools\n');

  // First, get a project ID
  let projectId;
  try {
    const projectsRes = await fetch('http://localhost:3457/api/studio-projects');
    const projectsData = await projectsRes.json();
    const projects = projectsData.projects || projectsData;
    projectId = projects[0].id;
    console.log(`üìÅ Using project: ${projects[0].name} (${projectId})\n`);
  } catch (error) {
    console.error('Failed to get projects:', error);
    return;
  }

  // Step 1: Start async workflow
  console.log('1Ô∏è‚É£ Starting async workflow via MCP...');
  
  const workflowDef = {
    projectId: projectId,
    workflow: [
      {
        id: 'step1',
        role: 'developer',
        task: `Write exactly 10 separate messages, each on a new line:
Message 1: "Step 1 starting"
Message 2: Run bash command: sleep 2
Message 3: "Step 2 starting" 
Message 4: Run bash command: sleep 2
Message 5: "Step 3 starting"
Message 6: Run bash command: sleep 2
Message 7: "Step 4 starting"
Message 8: Run bash command: sleep 2
Message 9: "Step 5 starting"
Message 10: "Step 1 complete"
Do this exactly as specified - 10 separate messages.`
      },
      {
        id: 'step2',
        role: 'developer',
        task: 'Take {step1.output} and add "Step 2 complete"',
        deps: ['step1']
      },
      {
        id: 'step3',
        role: 'developer',
        task: 'Final step: Output "All steps complete!"',
        deps: ['step2']
      }
    ]
  };

  // Get the threadId from invoke_async
  let threadId;
  try {
    // We'll need to call the MCP tool directly
    // For now, let's use regular invoke and get the threadId
    const response = await fetch('http://localhost:3457/api/invoke/async', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(workflowDef)
    });
    
    console.log('Response status:', response.status);
    console.log('Response headers:', response.headers);
    
    const result = await response.json();
    console.log('Full response:', JSON.stringify(result, null, 2));
    
    threadId = result.threadId;
    console.log(`üìù ThreadId: ${threadId}\n`);
  } catch (error) {
    console.error('Failed to start workflow:', error);
    return;
  }

  // Step 2: Wait a bit for workflow to start
  console.log('‚è≥ Waiting 5 seconds for workflow to start...');
  await new Promise(resolve => setTimeout(resolve, 5000));

  // Step 3: Check initial status
  console.log('2Ô∏è‚É£ Checking initial status...');
  try {
    const statusRes = await fetch(`http://localhost:3457/api/invoke-status/status/${threadId}`);
    const status = await statusRes.json();
    console.log('Status:', status.status);
    console.log('Current Step:', status.currentStep);
    console.log('Sessions:', status.sessionIds || {});
  } catch (error) {
    console.log('Status check failed:', error.message);
  }

  // Step 4: Restart server
  console.log('\n3Ô∏è‚É£ Restarting server to simulate crash...');
  try {
    await execAsync('npm run env:restart:dev');
    console.log('‚úÖ Server restarted');
  } catch (error) {
    console.error('Failed to restart server:', error);
  }

  // Step 5: Wait for server to come back
  console.log('\n‚è≥ Waiting 10 seconds for server to initialize...');
  await new Promise(resolve => setTimeout(resolve, 10000));

  // Step 6: Monitor for auto-resume
  console.log('\n4Ô∏è‚É£ Monitoring for auto-resume (2.5 minutes)...\n');
  
  let attempts = 0;
  const maxAttempts = 15; // 15 * 10 seconds = 2.5 minutes
  
  while (attempts < maxAttempts) {
    attempts++;
    
    try {
      const statusRes = await fetch(`http://localhost:3457/api/invoke-status/status/${threadId}`);
      const status = await statusRes.json();
      
      console.log(`[${attempts}/15] Status: ${status.status || 'unknown'}, Step: ${status.currentStep || 'none'}`);
      
      if (status.status === 'completed') {
        console.log('\n‚úÖ Workflow auto-resumed and completed!');
        console.log('Final status:', JSON.stringify(status, null, 2));
        return;
      }
      
      if (status.status === 'running' && status.currentStep !== 'step1' && attempts > 5) {
        console.log('üîÑ Workflow is resuming!');
      }
    } catch (error) {
      console.log(`[${attempts}/15] Status check failed:`, error.message);
    }
    
    await new Promise(resolve => setTimeout(resolve, 10000));
  }

  console.log('\n‚ùå Workflow did not auto-resume within timeout');
  console.log('\nThis could mean:');
  console.log('1. WorkflowMonitor needs more than 2 minutes to detect stale workflows');
  console.log('2. The workflow completed before the server restart');
  console.log('3. Auto-resume is not triggering properly');
  
  // Try manual resume
  console.log('\n5Ô∏è‚É£ Testing manual resume with same threadId...');
  try {
    const resumeRes = await fetch('http://localhost:3457/api/invoke', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...workflowDef,
        threadId // Same threadId to resume!
      })
    });
    
    const resumeResult = await resumeRes.json();
    console.log('\n‚úÖ Manual resume completed!');
    console.log('Results:', resumeResult.results);
    console.log('Summary:', resumeResult.summary);
  } catch (error) {
    console.log('‚ùå Manual resume failed:', error.message);
  }
}

// Run the test
runTest().catch(console.error);