import ky from 'ky';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
const API_BASE = 'http://localhost:3457/api';

async function testAutoResume() {
  console.log('üß™ Auto-Resume Test\n');
  
  // Get project
  const response = await ky.get(`${API_BASE}/studio-projects`).json();
  const projects = response.projects || response;
  const projectId = projects[0].id;
  console.log(`üìÅ Using project: ${projects[0].name}`);

  const threadId = `test-resume-${Date.now()}`;
  
  // Create a workflow with long-running first step
  const workflow = {
    workflow: [
      {
        id: 'long-task',
        role: 'developer',
        task: 'Simulate a long task: Count from 1 to 5, waiting 1 second between each number. Show each number. Then output "Long task complete"'
      },
      {
        id: 'quick-task',
        role: 'developer', 
        task: 'Quick task: Just output "Quick task complete"',
        deps: ['long-task']
      },
      {
        id: 'final-task',
        role: 'developer',
        task: 'Final task: Combine outputs and say "Workflow finished!"',
        deps: ['quick-task']
      }
    ],
    threadId: threadId,
    projectId: projectId
  };

  console.log(`\nüìù ThreadId: ${threadId}`);
  console.log('\n=== Starting Workflow ===\n');

  // Start workflow in background (not awaiting)
  const workflowPromise = ky.post(`${API_BASE}/invoke`, {
    json: workflow,
    timeout: false
  }).json();

  // Wait a bit for first step to start
  console.log('‚è≥ Waiting 3 seconds for workflow to start...');
  await new Promise(resolve => setTimeout(resolve, 3000));

  // Check initial status
  console.log('\nüìä Checking initial status...');
  let status = await ky.get(`${API_BASE}/invoke-status/status/${threadId}`).json();
  console.log(`Status: ${status.status}`);
  console.log(`Current Step: ${status.currentStep || 'N/A'}`);
  console.log(`Sessions: ${JSON.stringify(status.sessionIds || {})}`);

  // Find Claude process and kill it
  console.log('\nüí• Attempting to kill Claude process...');
  try {
    // Find Claude SDK processes
    const { stdout } = await execAsync('ps aux | grep -i "claude" | grep -v grep');
    const processes = stdout.split('\n').filter(line => line.includes('claude'));
    
    if (processes.length > 0) {
      console.log(`Found ${processes.length} Claude process(es)`);
      // Extract PIDs and kill them
      for (const proc of processes) {
        const parts = proc.trim().split(/\s+/);
        const pid = parts[1];
        if (pid && !isNaN(pid)) {
          console.log(`Killing PID: ${pid}`);
          try {
            await execAsync(`kill -9 ${pid}`);
          } catch (e) {
            console.log(`Failed to kill ${pid}: ${e.message}`);
          }
        }
      }
    } else {
      console.log('No Claude processes found - workflow may have completed');
    }
  } catch (error) {
    console.log('Process search/kill failed:', error.message);
  }

  // Wait a moment
  await new Promise(resolve => setTimeout(resolve, 2000));

  // Check status after kill
  console.log('\nüìä Status after interruption:');
  status = await ky.get(`${API_BASE}/invoke-status/status/${threadId}`).json();
  console.log(`Status: ${status.status}`);
  console.log(`Sessions: ${JSON.stringify(status.sessionIds || {})}`);

  if (status.status === 'completed') {
    console.log('\n‚úÖ Workflow already completed before we could interrupt it');
    const result = await workflowPromise;
    console.log('Results:', result.results);
    return;
  }

  // Now wait for auto-resume
  console.log('\n‚è≥ Waiting for WorkflowMonitor to detect stale workflow...');
  console.log('(Should take ~2 minutes)\n');

  let attempts = 0;
  const maxAttempts = 25; // 2.5 minutes
  
  while (attempts < maxAttempts) {
    attempts++;
    
    try {
      status = await ky.get(`${API_BASE}/invoke-status/status/${threadId}`).json();
      
      if (status.status === 'completed') {
        console.log('\n‚úÖ Workflow auto-resumed and completed!');
        console.log('Final sessions:', status.sessionIds);
        
        // Try to get the result
        try {
          const result = await workflowPromise;
          console.log('Results:', result.results);
        } catch (e) {
          console.log('Original request failed (expected), but workflow completed via auto-resume');
        }
        return;
      }
      
      if (status.status === 'running' && status.currentStep !== 'long-task') {
        console.log(`\nüîÑ Workflow resumed! Now on step: ${status.currentStep}`);
      }
    } catch (error) {
      console.log('Status check failed:', error.message);
    }
    
    process.stdout.write(`\r‚è±Ô∏è  Waiting... ${attempts * 6}s / ~120s`);
    await new Promise(resolve => setTimeout(resolve, 6000));
  }

  console.log('\n\n‚ùå Auto-resume did not trigger within timeout');
  console.log('This could mean:');
  console.log('1. WorkflowMonitor is not running');
  console.log('2. The stale threshold is longer than 2 minutes');
  console.log('3. The workflow completed before interruption');
  
  // Test manual resume
  console.log('\n=== Testing Manual Resume ===');
  console.log('Resuming with same threadId...\n');
  
  try {
    const resumeResult = await ky.post(`${API_BASE}/invoke`, {
      json: { ...workflow, threadId }, // Same threadId!
      timeout: 60000
    }).json();
    
    console.log('‚úÖ Manual resume successful!');
    console.log('Results:', resumeResult.results);
    console.log('Summary:', resumeResult.summary);
  } catch (error) {
    console.log('‚ùå Manual resume failed:', error.message);
  }
}

// Run test
testAutoResume()
  .then(() => {
    console.log('\n‚úÖ Test complete!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Test failed:', error);
    process.exit(1);
  });