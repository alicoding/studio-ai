#!/usr/bin/env node

/**
 * Comprehensive test for all three MCP AI systems:
 * 1. AI Capabilities (execute_*) - LangGraph with auto-session
 * 2. Agent Communication (@mention) - Claude SDK direct
 * 3. Orchestrator (batch_messages) - Multi-agent coordination
 */

const API_BASE = 'http://localhost:3456/api'

// Color codes for output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m'
}

function log(emoji, message, color = '') {
  console.log(`${color}${emoji} ${message}${colors.reset}`)
}

async function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}

// Test 1: AI Capabilities (LangGraph with auto-session)
async function testAICapabilities() {
  log('🧪', 'Testing AI Capabilities (execute_debugging)', colors.blue)
  
  try {
    // First call - no session specified
    log('1️⃣', 'First message (auto-creates session)...')
    const response1 = await fetch(`${API_BASE}/ai/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        capabilityId: 'debugging',
        input: 'Remember this: The test secret is APPLE',
        projectId: 'test-project',
        // No sessionId - will auto-create
      })
    })
    
    const result1 = await response1.json()
    log('📝', `Response: ${result1.content?.substring(0, 100)}...`)
    const sessionId = result1.sessionId
    log('🔑', `Session created: ${sessionId}`)
    
    await delay(1000)
    
    // Second call - continues same session by passing sessionId
    log('2️⃣', 'Second message (continues session)...')
    const response2 = await fetch(`${API_BASE}/ai/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        capabilityId: 'debugging',
        input: 'What was the test secret I told you?',
        projectId: 'test-project',
        sessionId: sessionId // MUST pass sessionId to continue
      })
    })
    
    const result2 = await response2.json()
    log('📝', `Response: ${result2.content?.substring(0, 100)}...`)
    
    if (result2.content?.includes('APPLE')) {
      log('✅', 'SUCCESS: AI Capabilities memory working!', colors.green)
    } else {
      log('❌', 'FAIL: AI Capabilities memory not working', colors.red)
    }
    
    // Third call - start new conversation
    log('3️⃣', 'Third message (start new conversation)...')
    const response3 = await fetch(`${API_BASE}/ai/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        capabilityId: 'debugging',
        input: 'What was the test secret?',
        projectId: 'test-project',
        // Explicitly start new - no memory of APPLE
      })
    })
    
    const result3 = await response3.json()
    log('📝', `Response: ${result3.content?.substring(0, 100)}...`)
    
    if (!result3.content?.includes('APPLE')) {
      log('✅', 'SUCCESS: New conversation started correctly!', colors.green)
    } else {
      log('❌', 'FAIL: Memory not cleared for new conversation', colors.red)
    }
    
  } catch (error) {
    log('❌', `AI Capabilities test failed: ${error.message}`, colors.red)
  }
}

// Test 2: Agent Communication (@mention)
async function testAgentCommunication() {
  log('\n🧪', 'Testing Agent Communication (@mention)', colors.magenta)
  
  try {
    // Send async message
    log('1️⃣', 'Sending async message to debugging agent...')
    const response1 = await fetch(`${API_BASE}/messages/mention`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        to: 'debugging',
        message: '@debugging Help me debug this async issue',
        fromAgentId: 'test-agent',
        projectId: 'test-project',
        wait: false // Async
      })
    })
    
    const result1 = await response1.json()
    log('📨', `Async message sent: ${JSON.stringify(result1)}`)
    
    await delay(1000)
    
    // Send sync message (wait for response)
    log('2️⃣', 'Sending sync message to debugging agent...')
    const response2 = await fetch(`${API_BASE}/messages/mention`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        to: 'debugging',
        message: '@debugging What is 2+2?',
        fromAgentId: 'test-agent',
        projectId: 'test-project',
        wait: true, // Sync - wait for response
        timeout: 30000
      })
    })
    
    const result2 = await response2.json()
    log('📩', `Sync response: ${JSON.stringify(result2).substring(0, 200)}...`)
    
    if (result2.responses) {
      log('✅', 'SUCCESS: Agent communication working!', colors.green)
    } else {
      log('❌', 'FAIL: No response from agent', colors.red)
    }
    
  } catch (error) {
    log('❌', `Agent communication test failed: ${error.message}`, colors.red)
  }
}

// Test 3: Orchestrator (batch_messages)
async function testOrchestrator() {
  log('\n🧪', 'Testing Orchestrator (batch_messages)', colors.yellow)
  
  try {
    // Send batch with dependencies
    log('1️⃣', 'Sending batch messages with orchestration...')
    const response = await fetch(`${API_BASE}/messages/batch`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        messages: [
          {
            id: 'msg1',
            targetAgentId: 'dev',
            content: 'Write a function to calculate fibonacci',
            projectId: 'test-project'
          },
          {
            id: 'msg2',
            targetAgentId: 'ux',
            content: 'Review the fibonacci function from dev',
            projectId: 'test-project',
            dependencies: ['msg1'] // Depends on msg1
          }
        ],
        fromAgentId: 'orchestrator',
        projectId: 'test-project',
        waitStrategy: 'all', // Wait for all
        timeout: 60000
      })
    })
    
    const result = await response.json()
    log('🎭', `Orchestration result: ${JSON.stringify(result).substring(0, 200)}...`)
    
    if (result.responses || result.trackingId) {
      log('✅', 'SUCCESS: Orchestrator working!', colors.green)
    } else {
      log('❌', 'FAIL: Orchestration failed', colors.red)
    }
    
    // Test parallel execution
    log('2️⃣', 'Testing parallel execution...')
    const response2 = await fetch(`${API_BASE}/messages/batch`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        messages: [
          {
            id: 'parallel1',
            targetAgentId: 'dev',
            content: 'What is your role?',
            projectId: 'test-project'
          },
          {
            id: 'parallel2',
            targetAgentId: 'ux',
            content: 'What is your role?',
            projectId: 'test-project'
          }
        ],
        fromAgentId: 'orchestrator',
        projectId: 'test-project',
        waitStrategy: 'all', // Both in parallel
        timeout: 30000
      })
    })
    
    const result2 = await response2.json()
    log('🎭', `Parallel result: ${JSON.stringify(result2).substring(0, 200)}...`)
    
  } catch (error) {
    log('❌', `Orchestrator test failed: ${error.message}`, colors.red)
  }
}

// Run all tests
async function runAllTests() {
  log('🚀', 'Testing all MCP AI systems...', colors.bright)
  
  await testAICapabilities()
  await testAgentCommunication()
  await testOrchestrator()
  
  log('\n✨', 'All tests complete!', colors.bright)
}

// Check if server is running
fetch(`${API_BASE}/health`)
  .then(() => runAllTests())
  .catch(() => {
    log('❌', 'Server not running! Start with: npm run server', colors.red)
  })