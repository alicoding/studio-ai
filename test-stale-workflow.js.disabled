#!/usr/bin/env node

import ky from 'ky';

async function testStaleWorkflow() {
  console.log('üß™ Testing WorkflowMonitor Auto-Resume (Stale Detection)\n');
  console.log('This test simulates a workflow that becomes unresponsive\n');

  // Get project
  let projectId;
  try {
    const projectsData = await ky.get('http://localhost:3457/api/studio-projects').json();
    const projects = projectsData.projects || projectsData;
    projectId = projects[0].id;
    console.log(`üìÅ Using project: ${projects[0].name}\n`);
  } catch (error) {
    console.error('Failed to get projects:', error);
    return;
  }

  // Create a workflow that will simulate becoming unresponsive
  const workflow = {
    projectId: projectId,
    workflow: [
      {
        id: 'step1',
        role: 'developer',
        task: 'This is step 1. Just say "Step 1 starting" and then output "Step 1 complete"'
      },
      {
        id: 'step2',
        role: 'developer',
        // This step will never execute if we kill the Claude process
        task: 'This is step 2. Say "Step 2 received: {step1.output}" and output "Step 2 complete"',
        deps: ['step1']
      },
      {
        id: 'step3',
        role: 'developer',
        task: 'Final step. Output "All steps finished!"',
        deps: ['step2']
      }
    ]
  };

  console.log('1Ô∏è‚É£ Starting workflow that will become stale...');
  
  // Start workflow async
  let threadId;
  try {
    const response = await ky.post('http://localhost:3457/api/invoke/async', {
      json: workflow
    }).json();
    
    threadId = response.threadId;
    console.log(`üìù ThreadId: ${threadId}`);
    console.log(`Status: ${response.status}\n`);
  } catch (error) {
    console.error('Failed to start workflow:', error);
    return;
  }

  // Wait for workflow to start
  console.log('‚è≥ Waiting 10 seconds for workflow to start...');
  await new Promise(resolve => setTimeout(resolve, 10000));

  // Check initial status
  console.log('\n2Ô∏è‚É£ Checking workflow status...');
  try {
    const status = await ky.get(`http://localhost:3457/api/invoke-status/status/${threadId}`).json();
    console.log(`Status: ${status.status}`);
    console.log(`Current Step: ${status.currentStep || 'unknown'}`);
    console.log(`Sessions:`, status.sessionIds || {});
  } catch (error) {
    console.log('Status check failed:', error.message);
  }

  // Now we wait for WorkflowMonitor to detect it as stale
  console.log('\n3Ô∏è‚É£ Waiting for WorkflowMonitor to detect stale workflow...');
  console.log('(This should take ~2 minutes)\n');

  let attempts = 0;
  const maxAttempts = 25; // 2.5 minutes
  let previousStatus = '';
  
  while (attempts < maxAttempts) {
    attempts++;
    
    try {
      const status = await ky.get(`http://localhost:3457/api/invoke-status/status/${threadId}`).json();
      const currentStatus = `${status.status || 'unknown'} @ ${status.currentStep || 'none'}`;
      
      // Show update only if status changed
      if (currentStatus !== previousStatus) {
        console.log(`[${new Date().toLocaleTimeString()}] Status: ${currentStatus}`);
        previousStatus = currentStatus;
        
        if (status.status === 'completed') {
          console.log('\n‚úÖ Workflow auto-resumed and completed!');
          console.log('Final sessions:', status.sessionIds);
          
          // Try to get the actual results
          try {
            // Since we used async, we need to check if results are available
            const finalStatus = await ky.post(`http://localhost:3457/api/invoke/status/${threadId}`, {
              json: { steps: workflow.workflow }
            }).json();
            
            if (finalStatus.currentState) {
              console.log('\nWorkflow outputs:');
              Object.entries(finalStatus.currentState.stepOutputs || {}).forEach(([step, output]) => {
                console.log(`- ${step}: ${output}`);
              });
            }
          } catch (e) {
            console.log('Could not retrieve detailed results');
          }
          
          return;
        }
      }
    } catch (error) {
      console.log(`[${new Date().toLocaleTimeString()}] Status check failed:`, error.message);
    }
    
    // Progress indicator
    process.stdout.write(`\r‚è±Ô∏è  Elapsed: ${attempts * 6}s / ~150s`);
    
    await new Promise(resolve => setTimeout(resolve, 6000));
  }

  console.log('\n\n‚ùå Workflow was not auto-resumed within timeout');
  
  // Let's check if it's actually registered with WorkflowMonitor
  console.log('\n4Ô∏è‚É£ Debugging: Manual resume test...');
  try {
    const resumeResult = await ky.post('http://localhost:3457/api/invoke', {
      json: { ...workflow, threadId },
      timeout: 60000
    }).json();
    
    console.log('\n‚úÖ Manual resume successful!');
    console.log('Results:', resumeResult.results);
  } catch (error) {
    console.log('‚ùå Manual resume failed:', error.message);
  }
}

// Run test
testStaleWorkflow()
  .then(() => {
    console.log('\n‚úÖ Test complete!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Test failed:', error);
    process.exit(1);
  });